#' @title GC Aware Peak Calling
#'
#' @description
#' This function calls ChIP-seq peaks using potential GC effects information.
#' Enrichment scores are calculated on sliding windows of prefiltered
#' large regions, with GC effects considered. Permutation analysis is
#' used to determine significant binding peaks.
#'
#' @param cov A list object returned by function \code{rc5end}.
#'
#' @param gcbias A list object returned by function \code{gcbias}.
#'
#' @param bdwidth A non-negative integer specifying ChIP-seq binding width.
#' Usually generated by function \code{bdwidth}. A bad estimation of bdwidth
#' results no meaning of downstream analysis.
#'
#' @param flank A non-negative integer specifying the flanking width of
#' ChIP-seq binding. This parameter provides the flexibility that reads
#' appear in flankings by decreased probabilities as increased distance
#' from binding region. This paramter helps to define the weight of GC
#' content calculation. Default is the half size of \code{bdwidth}. Note
#' that flank size won't largely affect results due to weighted strategy.
#'
#' @param prefilter A non-negative integer specifying the minimum of reads
#' to qualify a potential binding region. Regions with total of reads from
#' forward and reverse strands larger or equivalent to \code{prefilter} are
#' selected for downstream analysis. Default is 4.
#'
#' @param permute A non-negative integer specifying times of permutation to
#' be performed. Default is 10. When whole large genome is used, such as
#' human, 5 times of permutation could be enough.
#'
#' @param pv A numeric specifying p-value cutoff for significant
#' binding peaks. Default is 0.05.
#'
#' @param plot A logical vector which, when TRUE (default), returns density
#' plots of real and permutation enrichment scores.
#'
#' @param species A character specifying the symbol of species on which
#' ChIP-seq is generated. It will be used to extract DNA sequence
#' from BSgenome. For example, "Hsapiens" for human and "Mmusculus" for mouse.
#'
#' @param build A character specifying the ucsc genome build of given species,
#' such as "hg19" for "Hsapiens" and "mm10" for "Mmusculus".
#'
#' @return A GRanges of peaks with meta columns:
#' \item{es}{Estimated enrichment score.}
#' \item{pv}{p-value.}
#'
#' @import S4Vectors
#' @import IRanges
#' @import GenomicRanges
#' @importFrom BSgenome getSeq
#' @importFrom splines ns
#' @importFrom stats predict
#' @importFrom stats density
#' @importFrom stats ecdf
#' @importFrom graphics plot
#' @importFrom graphics lines
#' @importFrom graphics abline
#' @importFrom graphics legend
#' @importFrom methods as
#'
#' @export
#' @examples
#' bam <- system.file("extdata/chipseq.bam",package="gcapc")
#' cov <- rc5end(bam)
#' bdw <- bdwidth(cov)
#' gcb <- gcbias(cov,bdw,samp = 0.15)
#' peaks <- gcapc(cov,gcb,bdw)

gcapc <- function(cov,gcbias,bdwidth=200L,flank=round(bdwidth/2),
                  prefilter=4L,permute=10L,pv=0.05,plot=FALSE,
                  species="Hsapiens",build="hg19"){
    library(paste0("BSgenome.",species,".UCSC.",build),character.only=TRUE)
    cat("Starting to call peaks.\n")
    ### prefiltering regions
    cat("...... prefiltering regions\n")
    seqs <- sapply(cov$fwd,length)
    seqs <- floor(seqs/bdwidth-2)*bdwidth
    starts <- lapply(seqs, function(i) seq(1+bdwidth*2, i, bdwidth))
    ends <- lapply(seqs, function(i) seq(bdwidth*3, i, bdwidth))
    chrs <- rep(names(seqs), times=sapply(starts, length))
    region <- GRanges(chrs, IRanges(start=unlist(starts),end=unlist(ends)))
    regionsp <- split(region,seqnames(region))
    rcfwd <- unlist(viewSums(Views(cov$fwd,
                            ranges(shift(regionsp,-round(bdwidth/2))))))
    rcrev <- unlist(viewSums(Views(cov$rev,
                            ranges(shift(regionsp,round(bdwidth/2))))))
    regions <- region[rcfwd+rcrev >= prefilter]
    ## extend both ends
    regionsrc <- reduce(shift(resize(regions,bdwidth*4),-round(bdwidth*1.5)))
    regionsgc <- shift(resize(regionsrc,width(regionsrc)+bdwidth),
                       -round(bdwidth/2))
    ### gc content
    cat("...... caculating GC content\n")
    nr <- shift(resize(regionsgc,width(regionsgc)+flank*2),-flank)
    seqs <- getSeq(get(species),nr)
    gcpos <- gregexpr('(G)|(C)',seqs)
    weight <- c(seq_len(flank),rep(flank+1,bdwidth),rev(seq_len(flank)))
    k <- length(weight)
    gcposb <- vector("integer",sum(width(nr)))
    gcposbi <- rep(seq_along(nr),times=width(nr))
    gcposbsp <- split(gcposb,gcposbi)
    for(i in seq_along(nr)){
        gcposbsp[[i]][gcpos[[i]]] <- 1L
    }
    gcposbsprle <- as(gcposbsp,"RleList")
    gcnuml <- width(regionsgc)-bdwidth+1
    gcnum <- vector('numeric',sum(gcnuml))
    gcnumi <- rep(seq_along(nr),times=gcnuml)
    gc <- split(gcnum,gcnumi)
    for(i in seq_along(nr)){
        gc[[i]] <- round(runwtsum(gcposbsprle[[i]],k=k,wt=weight) /
                         (flank+bdwidth) / (flank+1),3)
        if(i%%500 == 0) cat('.')
    }
    cat('\n')
    ### gc weight
    cat("...... caculating GC effect weights\n")
    gcbase <- round(seq(0,1,0.001),3)
    mu0 <- predict(gcbias$glm0,data.frame(gc = gcbase),type="response")
    gcwbase <- round(Rle(median(gcbias$mu0[gcbias$z>0.5])/mu0),3)
    gcw <- lapply(gc,function(x) gcwbase[x*1000+1])
    ### reads count
    regionrcsp <- split(regionsrc,seqnames(regionsrc))
    rcfwd <- unlist(viewApply(Views(cov$fwd,ranges(regionrcsp)),
                              runsum,k=bdwidth))
    rcrev <- unlist(viewApply(Views(cov$rev,ranges(regionrcsp)),
                              runsum,k=bdwidth))
    ### enrichment score
    cat("...... estimating enrichment score\n")
    esl <- width(regionsrc)-2*bdwidth
    rc1 <- unlist(as(lapply(seq_along(esl),function(i)
                            rcfwd[[i]][seq_len(esl[i])]),'NumericList'))
    rc2 <- unlist(as(lapply(seq_along(esl),function(i)
                     rcfwd[[i]][seq_len(esl[i])+bdwidth+1]),'NumericList'))
    rc3 <- unlist(as(lapply(seq_along(esl),function(i)
                     rcrev[[i]][seq_len(esl[i])]),'NumericList'))
    rc4 <- unlist(as(lapply(seq_along(esl),function(i)
                     rcrev[[i]][seq_len(esl[i])+bdwidth+1]),'NumericList'))
    gc1 <- unlist(as(lapply(seq_along(esl),function(i)
                     gcw[[i]][seq_len(esl[i])+bdwidth]),'NumericList'))
    gc2 <- unlist(as(lapply(seq_along(esl),function(i)
                     gcw[[i]][seq_len(esl[i])+bdwidth*2+1]),'NumericList'))
    gc3 <- unlist(as(lapply(seq_along(esl),function(i)
                     gcw[[i]][seq_len(esl[i])]),'NumericList'))
    es <- 2*sqrt(rc1*rc4)*gc1-rc3*gc3-rc2*gc2
    ### permutation analysis
    cat("...... permutation analysis\n")
    esr <- list()
    rcs <- c(rc1,rc2,rc3,rc4)
    for(i in seq_len(permute)){
        idx <- sample.int(length(rcs))
        rcr1 <- rcs[idx[seq_along(es)]]
        rcr2 <- rcs[idx[seq_along(es)+length(es)]]
        rcr3 <- rcs[idx[seq_along(es)+length(es)*2]]
        rcr4 <- rcs[idx[seq_along(es)+length(es)*3]]
        esr[[i]] <- 2*sqrt(rcr1*rcr4)*gc1-rcr3*gc3-rcr2*gc2

    }
    esveci <- rep(seq_along(regionsrc),times=width(regionsrc)-2*bdwidth)
    eslst <- split(es,esveci)
    ### report peaks
    cat('...... reporting peaks\n')
    perm <- unlist(esr)
    sccut <- quantile(perm,1-pv)
    cat('......... enrichment scores cut at',sccut,'\n')
    if(plot){
        cat('......... ploting enrichment scores\n')
        adjust <- diff(range(perm)) / diff(range(es))
        plot(density(es),col='red',xlab='enrichment score',
             main=paste('es determined by pvalue',pv))
        lines(density(perm,adjust=adjust),col='blue')
        abline(v=sccut,lty=2,col='purple')
        legend('topright',c('real','perm'),lty=1,
               col=c('red','blue'),bty='n')
    }
    cat('......... reporting peak bumps\n')
    esrlt <- as(eslst,'RleList')
    esrltsl <- slice(esrlt,sccut,rangesOnly=TRUE)
    esrltsl0 <- slice(esrlt,0,rangesOnly=TRUE)
    esrltsle <- reduce(shift(resize(esrltsl,width(esrltsl)+bdwidth),
                             -floor(bdwidth/2)))
    peaksir <- intersect(esrltsl0,esrltsle)
    peaksir <- peaksir[width(peaksir)>=floor(bdwidth/2)]
    cat('......... summarizing peak score and pvalue\n')
    peaksc <- unlist(viewMaxs(Views(esrlt,peaksir)))
    peaksir <- unlist(peaksir)
    regionids <- as.integer(names(peaksir))
    peaksir <- shift(peaksir,start(regionsrc)[regionids]+bdwidth)
    peaks <- GRanges(seqnames(regionsrc)[regionids],peaksir,es=peaksc)
    peaksrd <- reduce(peaks,min.gapwidth=floor(bdwidth/2),with.revmap=TRUE)
    mcols(peaksrd)$es <- sapply(mcols(peaksrd)$revmap,function(i)
                                max(mcols(peaks)$es[i]))
    mcols(peaksrd)$revmap <- NULL
    pvs <- ecdf(perm)
    mcols(peaksrd)$pv <- 1 - pvs(mcols(peaksrd)$es)
    peaksrd
}
