#' @title ChIP-seq GC Effects Estimation
#'
#' @description
#' GC effects are estimated based on effective GC content and reads count
#' on genome-wide windows, using generalized linear mixture models. Genome
#' wide windows are randomly sampled with given proportions. GC effects of
#' background and foreground are estimated separately, while effects on
#' background level act more likely to be the real bias.
#'
#' @param cov A list object returned by function \code{read5endCoverage}.
#'
#' @param bdwidth A non-negative integer vector with two elements 
#' specifying ChIP-seq binding width and peak detection half window size.
#' Usually generated by function \code{bindWidth}. A bad estimation of
#' bdwidth results no meaning of downstream analysis. 
#'
#' @param flank A non-negative integer specifying the flanking width of
#' ChIP-seq binding. This parameter provides the flexibility that reads
#' appear in flankings by decreased probabilities as increased distance
#' from binding region. This paramter helps to define effective GC
#' content calculation. Default is NULL, which means this paramater will
#' be calculated from \code{bdwidth}. However, if customized numbers 
#' provided, there won't be recalucation for this parameter; instead, the
#' 2nd elements of \code{bdwidth} will be recalculated based on \code{flank}.
#'
#' @param samp A numeric specifying the proportion of regions to be
#' randomized for GC effects estimation. Default is 0.05.
#' 
#' @param plot A logical vector which, when TRUE (default), returns plots
#' of intermediate results.
#' 
#' @param gcrange A non-nagative numeric vector with length 2. This vector
#' set the range of GC content to filter regions. For human, most regions
#' have GC content between 0.3 and 0.8, which is set as the default. Other
#' regions with GC content beyond this range will be ignored.
#'
#' @param mu0 A non-negative numeric initiating read count signals for
#' background regions. This is treated as a starting value for EM algorithm.
#' Default is 1.
#'
#' @param mu1 A non-negative numeric initiating read count signals for
#' foreground regions. This is treated as a starting value for EM algorithm.
#' Default is 50.
#'
#' @param p A non-negative numeric specifying the proportion of foreground
#' regions in all estimated regions. This is treated as a starting value for
#' EM algorithm. Default is 0.02.
#'
#' @param converge A non-negative numeric specifying the condition of EM
#' algorithm termination. EM algorithm stops when the ratio of log likelihood
#' increment to whole log likelihood is less or equivalent to 
#' \code{converge}.
#'
#' @param emtrace A logical vector which, when TRUE (default), allows to 
#' print the trace of log likelihood changes in EM iterations.
#'
#' @param genome A \link[BSgenome]{BSgenome} object containing the sequences
#' of the reference genome that was used to align the reads, or the name of
#' this reference genome specified in a way that is accepted by the
#' \code{\link[BSgenome]{getBSgenome}} function defined in the \pkg{BSgenome}
#' software package. In that case the corresponding BSgenome data package
#' needs to be already installed (see \code{?\link[BSgenome]{getBSgenome}} in
#' the \pkg{BSgenome} package for the details).
#'
#' @return A list of objects
#' \item{glm0}{Estimated generalized linear model for background GC effects.}
#' \item{glm1}{Estimated generalized linear model for foreground GC effects.}
#' \item{mu0}{Predicted signals by GC content if belongs to background.}
#' \item{mu1}{Predicted signals by GC content if belongs to foreground.}
#' \item{z}{Estimated probabilty of being foreground for input windows.}
#' \item{p}{Estimated proportion of foreground regions.}
#' \item{ll}{Converged log likelihood.}
#'
#' @import S4Vectors
#' @import IRanges
#' @import GenomicRanges
#' @import Biostrings
#' @importFrom BSgenome getBSgenome
#' @importFrom BSgenome getSeq
#' @importFrom splines ns
#' @importFrom grDevices colorRampPalette
#' @importFrom graphics layout
#' @importFrom graphics plot
#' @importFrom graphics axis
#' @importFrom graphics lines
#' @importFrom stats dpois
#' @importFrom stats glm
#' @importFrom stats predict
#'
#' @export
#' @examples
#' bam <- system.file("extdata", "chipseq.bam", package="gcapc")
#' cov <- read5endCoverage(bam)
#' bdw <- bindWidth(cov)
#' gcb <- gcEffects(cov, bdw, samp = 0.15)

gcEffects <- function(cov,bdwidth,flank=NULL,samp=0.05,plot=TRUE,
                      gcrange=c(0.3,0.8),mu0=1,mu1=50,p=0.02,converge=1e-3,
                      emtrace=TRUE,genome="hg19"){
    genome <- getBSgenome(genome)
    bdw <- bdwidth[1]
    halfbdw <- floor(bdw/2)
    if(is.null(flank)){
      pdwh <- bdwidth[2]
      flank <- pdwh-bdw+halfbdw
    }else{
      pdwh <- flank+bdw-halfbdw
    }
    ### regions and reads count
    cat("Starting to estimate GC effects.\n")
    cat("...... Sampling regions\n")
    seqs <- sapply(cov$fwd,length)
    seqs <- floor(seqs/bdw-2)*bdw
    starts <- lapply(seqs, function(i) seq(1+bdw*2, i, bdw))
    ends <- lapply(seqs, function(i) seq(bdw*3, i, bdw))
    chrs <- rep(names(seqs), times=sapply(starts, length))
    sampidx <- sort(sample.int(length(chrs),ceiling(length(chrs)*samp)))
    region <- GRanges(chrs[sampidx], IRanges(start=unlist(starts)[sampidx],
                                       end=unlist(ends)[sampidx]))
    cat("......... Estimating using",length(region),"regions\n")
    regionsp <- resize(split(region,seqnames(region)),pdwh)
    cat("...... Counting reads\n")
    rcfwd <- unlist(viewSums(Views(cov$fwd,
                            ranges(shift(regionsp,-flank)))))
    rcrev <- unlist(viewSums(Views(cov$rev,
                            ranges(shift(regionsp,halfbdw)))))
    if(plot){
        layout(matrix(1:2,1,2))
        idxx <- sample.int(length(region),min(50000,length(region)))
        plot(rcfwd[idxx],rcrev[idxx],
             main=paste('rc: shifted',halfbdw,"; cor:",
                        round(cor(rcfwd,rcrev),3),"; flank:",flank),
             ylab='reverse strand',xlab='forward strand')
    }
    ### effective gc content
    cat("...... Calculating GC content with flanking",flank,"\n")
    rwidth <- width(region[1])
    nr <- shift(resize(region,rwidth + flank*2),-flank)
    seqs <- getSeq(genome,nr)
    gcpos <- startIndex(vmatchPattern("S", seqs, fixed="subject"))
    w <- flank+halfbdw
    weight <- (1-abs(seq(-w,w)/w)^3)^3
    weight <- weight/sum(weight)
    gc <- round(sapply(gcpos,function(x) sum(weight[x])),3)
    ### em algorithms
    cat("...... Estimating GC effects\n")
    gc <- rep(gc,2)
    rc <- c(rcfwd,rcrev)
    idx <- gc>=gcrange[1] & gc<=gcrange[2] & !is.na(rc) & !is.na(gc)
    y <- rc[idx]
    gc <- gc[idx]
    logp1 <- dpois(y, lambda = mu1, log = TRUE)
    logp0 <- dpois(y, lambda = mu0, log = TRUE)
    z <- 1/(1+exp(logp0-logp1)*(1-p)/p)
    llf <- sum(z*(logp1+log(p)) + (1-z)*(logp0+log(1-p)))
    llgap <- llf
    i <- 0
    while(abs(llgap) > (abs(llf) * converge) && i < 100){
        p <- (2+sum(z))/(2*2+length(z))
        dat <- data.frame(y=y,gc=gc)
        dat1 <- dat[z>=0.5,]
        dat0 <- dat[z<0.5,]
        lmns0 <- glm(y ~ ns(gc, df = 2), data=dat0, family="poisson")
        lmns1 <- glm(y ~ ns(gc, df = 2), data=dat1, family="poisson")
        predY0 <- predict(lmns0, data.frame(gc = gc),type="response")
        predY1 <- predict(lmns1, data.frame(gc = gc),type="response")
        logp1 <- dpois(y, lambda = predY1, log = TRUE)
        logp0 <- dpois(y, lambda = predY0, log = TRUE)
        z <- 1/(1+exp(logp0-logp1)*(1-p)/p)
        if(sum(z>=0.5) < length(gc)*0.0005 | sum(z<0.5) < length(gc)*0.0005)
            break;
        lli <- sum(z*(logp1+log(p)) + (1-z)*(logp0+log(1-p)))
        llgap <- lli - llf
        llf <- lli
        i <- i + 1
        if(emtrace)
            cat("......... Iteration",i,'\tll',llf,'\tincrement',llgap,'\n')
    }
    ### gc effects
    gcbias <- list(glm0=lmns0,glm1=lmns1,
                   mu0=predY0,mu1=predY1,z=z,p=p,ll=llf)
    if(plot){
        tmp <- sum(idx)
        idx0 <- sample.int(tmp,min(100000,tmp))
        rbPal <- colorRampPalette(c('green','orange'))
        color <- rbPal(20)[as.numeric(cut(gcbias$z[idx0],breaks = 20))]
        plot(gc[idx0],rc[idx][idx0]+0.5,col=color,xlim=gcrange,
             pch=20,main="gc effects",
             xlab='gc content',ylab="reads count",log='y',yaxt='n')
        idx00 <- sample.int(tmp,min(5000,tmp))
        idx00 <- idx00[order(gc[idx00])]
        lines(gc[idx00],gcbias$mu1[idx00]+0.5,col='red',lwd=3)
        lines(gc[idx00],gcbias$mu0[idx00]+0.5,col='blue',lwd=3)
        axis(side=2, at=c(0,2^(0:10))+0.5, labels=c(0,2^(0:10)))
    }
    gcbias
}
