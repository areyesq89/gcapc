#' @title ChIP-seq GC Effects Estimation
#'
#' @description
#' GC effects are estimated based on weighted GC content and reads count
#' on genome-wide windows, using generalized linear mixture models. Genome
#' wide windows are randomly sampled with given proportions. GC effects of
#' background and foreground are estimated separately, while effects on
#' background level act more likely to be the real bias.
#'
#' @param cov A list object returned by function \code{rc5end}.
#'
#' @param bdwidth A non-negative integer specifying ChIP-seq binding width.
#' Usually generated by function \code{bdwidth}. A bad estimation of bdwidth
#' results no meaning of downstream analysis.
#'
#' @param flank A non-negative integer specifying the flanking width of
#' ChIP-seq binding. This parameter provides the flexibility that reads
#' appear in flankings by decreased probabilities as increased distance
#' from binding region. This paramter helps to define the weight of GC
#' content calculation. Default is the half size of \code{bdwidth}. Note
#' that flank size won't largely affect results due to weighted strategy.
#'
#' @param samp A numeric specifying the proportion of regions to be
#' randomized for GC effects estimation. Default is 0.05.
#'
#' @param gcrange A non-nagative numeric vector with length 2. This vector
#' set the range of GC content to filter regions. For human, most regions
#' have GC content between 0.3 and 0.8, which is set as the default. Other
#' regions with GC content beyond this range will be ignored.
#'
#' @param plot A logical vector which, when TRUE (default), returns plots of
#' intermediate results.
#'
#' @param mu0 A non-negative numeric initiating read count signals for
#' background regions. This is treated as a starting value for EM algorithm.
#' Default is 1.
#'
#' @param mu1 A non-negative numeric initiating read count signals for
#' foreground regions. This is treated as a starting value for EM algorithm.
#' Default is 50.
#'
#' @param p A non-negative numeric specifying the proportion of foreground
#' regions in all estimated regions. This is treated as a starting value for
#' EM algorithm. Default is 0.02.
#'
#' @param converge A non-negative numeric specifying the condition of EM
#' algorithm termination. EM algorithm stops when the ratio of log likelihood
#' increment to whole log likelihood is less or equivalent to \code{converge}.
#'
#' @param emtrace A logical vector which, when TRUE (default), allows to print
#' the trace of log likelihood changes in EM iterations.
#'
#' @param species A character specifying the symbol of species on which
#' ChIP-seq is generated. It will be used to extract DNA sequence
#' from BSgenome. For example, "Hsapiens" for human and "Mmusculus" for mouse.
#'
#' @param build A character specifying the ucsc genome build of given species,
#' such as "hg19" for "Hsapiens" and "mm10" for "Mmusculus".
#'
#' @return A list of objects
#' \item{glm0}{Estimated generalized linear model for background GC effects.}
#' \item{glm1}{Estimated generalized linear model for foreground GC effects.}
#' \item{mu0}{Predicted signals by GC content if belongs to background.}
#' \item{mu1}{Predicted signals by GC content if belongs to foreground.}
#' \item{z}{Estimated probabilty of being foreground for input windows.}
#' \item{p}{Estimated proportion of foreground regions.}
#' \item{ll}{Converged log likelihood.}
#'
#' @import S4Vectors
#' @import IRanges
#' @import GenomicRanges
#' @importFrom BSgenome getSeq
#' @importFrom splines ns
#' @importFrom grDevices colorRampPalette
#' @importFrom graphics layout
#' @importFrom graphics plot
#' @importFrom graphics axis
#' @importFrom graphics lines
#' @importFrom stats dpois
#' @importFrom stats glm
#' @importFrom stats predict
#'
#' @export
#' @examples
#' bam <- system.file("extdata/chipseq.bam",package="gcapc")
#' cov <- rc5end(bam)
#' bdw <- bdwidth(cov)
#' gcb <- gcbias(cov,bdw,samp = 0.15)

gcbias <- function(cov,bdwidth=200L,flank=round(bdwidth/2),
                   samp=0.05,gcrange=c(0.3,0.8),plot=TRUE,
                   mu0=1,mu1=50,p=0.02,converge=1e-5,emtrace=TRUE,
                   species="Hsapiens",build="hg19"){
    library(paste0("BSgenome.",species,".UCSC.",build),character.only=TRUE)
    ### regions and reads count
    cat("Starting to estimate GC effects.\n")
    cat("...... sampling regions\n")
    seqs <- sapply(cov$fwd,length)
    seqs <- floor(seqs/bdwidth-2)*bdwidth
    starts <- lapply(seqs, function(i) seq(1+bdwidth*2, i, bdwidth))
    ends <- lapply(seqs, function(i) seq(bdwidth*3, i, bdwidth))
    chrs <- rep(names(seqs), times=sapply(starts, length))
    sampidx <- sort(sample.int(length(chrs),ceiling(length(chrs)*samp)))
    region <- GRanges(chrs[sampidx], IRanges(start=unlist(starts)[sampidx],
                                       end=unlist(ends)[sampidx]))
    cat("......... estimating using",length(region),"regions\n")
    regionsp <- split(region,seqnames(region))
    cat("...... counting reads\n")
    rcfwd <- unlist(viewSums(Views(cov$fwd,
                            ranges(shift(regionsp,-round(bdwidth/2))))))
    rcrev <- unlist(viewSums(Views(cov$rev,
                            ranges(shift(regionsp,round(bdwidth/2))))))
    if(plot){
        layout(matrix(1:2,1,2))
        idxx <- sample.int(length(region),min(50000,length(region)))
        plot(rcfwd[idxx],rcrev[idxx],
             main=paste('reads count: both shifted',round(bdwidth/2)),
             ylab='reverse strand',xlab='forward strand')
    }
    ### weighted gc content
    cat("...... calculating GC content with flanking",flank,"\n")
    rwidth <- width(region[1])
    nr <- shift(resize(region,rwidth + flank*2),-flank)
    seqs <- getSeq(get(species),nr)
    gcpos <- gregexpr('(G)|(C)',seqs)
    weight <- c(seq_len(flank),rep(flank+1,rwidth),rev(seq_len(flank)))
    gcnumw <- sapply(gcpos,function(x) sum(weight[x]))
    gcnumw[gcnumw==(sum(weight)-1)] <- 0
    gc <- round(gcnumw / (flank+rwidth) / (flank+1),3)
    ### em algorithms
    cat("...... estimating GC effects\n")
    gc <- rep(gc,2)
    rc <- c(rcfwd,rcrev)
    idx <- gc>=gcrange[1] & gc<=gcrange[2] & !is.na(rc) & !is.na(gc)
    y <- rc[idx]
    gc <- gc[idx]
    logp1 <- dpois(y, lambda = mu1, log = TRUE)
    logp0 <- dpois(y, lambda = mu0, log = TRUE)
    z <- 1/(1+exp(logp0-logp1)*(1-p)/p)
    llf <- sum(z*(logp1+log(p)) + (1-z)*(logp0+log(1-p)))
    llgap <- llf
    i <- 0
    while(abs(llgap) > (abs(llf) * converge) && i < 100){
        p <- (2+sum(z))/(2*2+length(z))
        dat <- data.frame(y=y,gc=gc)
        dat1 <- dat[z>=0.5,]
        dat0 <- dat[z<0.5,]
        lmns0 <- glm(y ~ ns(gc, df = 2), data=dat0, family="poisson")
        lmns1 <- glm(y ~ ns(gc, df = 2), data=dat1, family="poisson")
        predY0 <- predict(lmns0, data.frame(gc = gc),type="response")
        predY1 <- predict(lmns1, data.frame(gc = gc),type="response")
        #para <- list(p=p,mu1=predY1,mu0=predY0,z=z,glm=lmns0,glm1=lmns1)
        logp1 <- dpois(y, lambda = predY1, log = TRUE)
        logp0 <- dpois(y, lambda = predY0, log = TRUE)
        z <- 1/(1+exp(logp0-logp1)*(1-p)/p)
        if(sum(z>=0.5) < length(gc)*0.0005 | sum(z<0.5) < length(gc)*0.0005)
            break;
        lli <- sum(z*(logp1+log(p)) + (1-z)*(logp0+log(1-p)))
        llgap <- lli - llf
        llf <- lli
        i <- i + 1
        if(emtrace)
            cat("......... iteration",i,'\tll',llf,'\tincrement',llgap,'\n')
    }
    ### gcbias
    gcbias <- list(glm0=lmns0,glm1=lmns1,mu0=predY0,mu1=predY1,z=z,p=p,ll=llf)
    if(plot){
        tmp <- sum(idx)
        idx0 <- sample.int(tmp,min(100000,tmp))
        rbPal <- colorRampPalette(c('green','orange'))
        color <- rbPal(20)[as.numeric(cut(gcbias$z[idx0],breaks = 20))]
        plot(gc[idx0],rc[idx][idx0]+0.5,col=color,xlim=gcrange,
             pch=20,main=paste("gc effects: bdwidth",bdwidth),
             xlab='gc content',ylab="reads count",log='y',yaxt='n')
        idx00 <- sample.int(tmp,min(5000,tmp))
        idx00 <- idx00[order(gc[idx00])]
        lines(gc[idx00],gcbias$mu1[idx00]+0.5,col='red',lwd=3)
        lines(gc[idx00],gcbias$mu0[idx00]+0.5,col='blue',lwd=3)
        axis(side=2, at=c(0,2^(0:10))+0.5, labels=c(0,2^(0:10)))
    }
    gcbias
}
