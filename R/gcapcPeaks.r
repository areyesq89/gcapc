#' @title GC Effects Aware Peak Calling
#'
#' @description
#' This function calls ChIP-seq peaks using potential GC effects information.
#' Enrichment scores are calculated on sliding windows of prefiltered
#' large regions, with GC effects considered. Permutation analysis is
#' used to determine significant binding peaks.
#'
#' @param cov A list object returned by function \code{read5endCoverage}.
#'
#' @param gcbias A list object returned by function \code{gcEffects}.
#'
#' @param bdwidth A non-negative integer specifying ChIP-seq binding width.
#' Usually generated by function \code{bindWidth}. A bad estimation of 
#' bdwidth results no meaning of downstream analysis.Odd number is 
#' preferred by the built in tricube smoothed weight.
#'
#' @param flank A non-negative integer specifying the flanking width of
#' ChIP-seq binding. This parameter provides the flexibility that reads
#' appear in flankings by decreased probabilities as increased distance
#' from binding region. This paramter helps to define the weight of GC
#' content calculation. Default is the half size of \code{bindWidth}. Note
#' that flank size won't largely affect results due to weighted strategy.
#'
#' @param prefilter A non-negative integer specifying the minimum of reads
#' to qualify a potential binding region. Regions with total of reads from
#' forward and reverse strands larger or equivalent to \code{prefilter} are
#' selected for downstream analysis. Default is 4.
#'
#' @param permute A non-negative integer specifying times of permutation to
#' be performed. Default is 10. When whole large genome is used, such as
#' human, 5 times of permutation could be enough.
#'
#' @param pv A numeric specifying p-value cutoff for significant
#' binding peaks. Default is 0.05.
#'
#' @param plot A logical vector which, when TRUE (default), returns density
#' plots of real and permutation enrichment scores.
#'
#' @param genome A \link[BSgenome]{BSgenome} object containing the sequences
#' of the reference genome that was used to align the reads, or the name of
#' this reference genome specified in a way that is accepted by the
#' \code{\link[BSgenome]{getBSgenome}} function defined in the \pkg{BSgenome}
#' software package. In that case the corresponding BSgenome data package
#' needs to be already installed (see \code{?\link[BSgenome]{getBSgenome}} in
#' the \pkg{BSgenome} package for the details).
#' 
#' @return A GRanges of peaks with meta columns:
#' \item{es}{Estimated enrichment score.}
#' \item{pv}{p-value.}
#'
#' @import S4Vectors
#' @import IRanges
#' @import GenomicRanges
#' @import Biostrings
#' @importFrom BSgenome getBSgenome
#' @importFrom BSgenome getSeq
#' @importFrom splines ns
#' @importFrom stats predict
#' @importFrom stats density
#' @importFrom stats ecdf
#' @importFrom graphics plot
#' @importFrom graphics lines
#' @importFrom graphics abline
#' @importFrom graphics legend
#' @importFrom methods as
#'
#' @export
#' @examples
#' bam <- system.file("extdata", "chipseq.bam", package="gcapc")
#' cov <- read5endCoverage(bam)
#' bdw <- bindWidth(cov)
#' gcb <- gcEffects(cov, bdw, samp = 0.15)
#' gcapcPeaks(cov, gcb, bdw)

gcapcPeaks <- function(cov,gcbias,bdwidth,flank=floor(bdwidth/2),
                  prefilter=4L,permute=10L,pv=0.05,plot=FALSE,
                  genome="hg19"){
    genome <- getBSgenome(genome)
    cat("Starting to call peaks.\n")
    ### prefiltering regions
    cat("...... prefiltering regions\n")
    seqs <- sapply(cov$fwd,length)
    seqs <- floor(seqs/bdwidth-2)*bdwidth
    starts <- lapply(seqs, function(i) seq(1+bdwidth*2, i, bdwidth))
    ends <- lapply(seqs, function(i) seq(bdwidth*3, i, bdwidth))
    chrs <- rep(names(seqs), times=sapply(starts, length))
    region <- GRanges(chrs, IRanges(start=unlist(starts),end=unlist(ends)))
    regionsp <- split(region,seqnames(region))
    halfbdw <- floor(bdwidth/2)
    rcfwd <- unlist(viewSums(Views(cov$fwd,
                            ranges(shift(regionsp,-halfbdw)))))
    rcrev <- unlist(viewSums(Views(cov$rev,
                            ranges(shift(regionsp,halfbdw)))))
    regions <- region[rcfwd+rcrev >= prefilter]
    ## extend both ends
    regionsrc <- reduce(shift(resize(regions,halfbdw*8+1),-halfbdw*3))
    regionsgc <- shift(resize(regionsrc,width(regionsrc)+halfbdw*2),-halfbdw)
    ### gc content
    cat("...... caculating GC content\n")
    nr <- shift(resize(regionsgc,width(regionsgc)+flank*2),-flank)
    seqs <- getSeq(genome,nr)
    gcpos <- startIndex(vmatchPattern("S", seqs, fixed="subject"))
    w <- flank+halfbdw
    weight <- (1-abs(seq(-w,w)/w)^3)^3
    weight <- weight/sum(weight)
    k <- length(weight)
    gcposb <- vector("integer",sum(width(nr)))
    gcposbi <- rep(seq_along(nr),times=width(nr))
    gcposbsp <- split(gcposb,gcposbi)
    for(i in seq_along(nr)){
        gcposbsp[[i]][gcpos[[i]]] <- 1L
    }
    gcposbsprle <- as(gcposbsp,"RleList")
    gcnuml <- width(regionsgc)-halfbdw*2
    gcnum <- vector('numeric',sum(gcnuml))
    gcnumi <- rep(seq_along(nr),times=gcnuml)
    gc <- split(gcnum,gcnumi)
    for(i in seq_along(nr)){
        gc[[i]] <- round(runwtsum(gcposbsprle[[i]],k=k,wt=weight),3)
        if(i%%500 == 0) cat('.')
    }
    cat('\n')
    ### gc weight
    cat("...... caculating GC effect weights\n")
    gcbase <- round(seq(0,1,0.001),3)
    mu0 <- predict(gcbias$glm0,data.frame(gc = gcbase),type="response")
    gcwbase <- round(Rle(median(gcbias$mu0[gcbias$z>0.5])/mu0),3)
    gcw <- lapply(gc,function(x) gcwbase[x*1000+1])
    ### reads count
    regionrcsp <- split(regionsrc,seqnames(regionsrc))
    rcfwd <- unlist(viewApply(Views(cov$fwd,ranges(regionrcsp)),
                              runsum,k=bdwidth))
    rcrev <- unlist(viewApply(Views(cov$rev,ranges(regionrcsp)),
                              runsum,k=bdwidth))
    ### enrichment score
    cat("...... estimating enrichment score\n")
    esl <- width(regionsrc)-halfbdw*4
    rc1 <- unlist(as(lapply(seq_along(esl),function(i)
                            rcfwd[[i]][seq_len(esl[i])]),'NumericList'))
    rc2 <- unlist(as(lapply(seq_along(esl),function(i)
                     rcfwd[[i]][seq_len(esl[i])+halfbdw*2]),'NumericList'))
    rc3 <- unlist(as(lapply(seq_along(esl),function(i)
                     rcrev[[i]][seq_len(esl[i])]),'NumericList'))
    rc4 <- unlist(as(lapply(seq_along(esl),function(i)
                     rcrev[[i]][seq_len(esl[i])+halfbdw*2]),'NumericList'))
    gcw1 <- unlist(as(lapply(seq_along(esl),function(i)
                     gcw[[i]][seq_len(esl[i])+halfbdw*2]),'NumericList'))
    gcw2 <- unlist(as(lapply(seq_along(esl),function(i)
                     gcw[[i]][seq_len(esl[i])+halfbdw*4]),'NumericList'))
    gcw3 <- unlist(as(lapply(seq_along(esl),function(i)
                     gcw[[i]][seq_len(esl[i])]),'NumericList'))
    es <- round(2*sqrt(rc1*rc4)*gcw1-rc3*gcw3-rc2*gcw2,3)
    ### permutation analysis
    cat("...... permutation analysis\n")
    esr <- list()
    rcs <- c(rc1,rc2,rc3,rc4)
    for(i in seq_len(permute)){
        idx <- sample.int(length(rcs))
        rcr1 <- rcs[idx[seq_along(es)]]
        rcr2 <- rcs[idx[seq_along(es)+length(es)]]
        rcr3 <- rcs[idx[seq_along(es)+length(es)*2]]
        rcr4 <- rcs[idx[seq_along(es)+length(es)*3]]
        esr[[i]] <- round(2*sqrt(rcr1*rcr4)*gcw1-rcr3*gcw3-rcr2*gcw2,3)

    }
    esveci <- rep(seq_along(regionsrc),times=width(regionsrc)-4*halfbdw)
    eslst <- split(es,esveci)
    ### report peaks
    cat('...... reporting peaks\n')
    perm <- unlist(esr)
    sccut <- quantile(perm,1-pv)
    cat('......... enrichment scores cut at',sccut,'\n')
    if(plot){
        cat('......... ploting enrichment scores\n')
        adjust <- diff(range(perm)) / diff(range(es))
        plot(density(es),col='red',xlab='enrichment score',
             main=paste('es determined by pvalue',pv))
        lines(density(perm,adjust=adjust),col='blue')
        abline(v=sccut,lty=2,col='purple')
        legend('topright',c('real','perm'),lty=1,
               col=c('red','blue'),bty='n')
    }
    cat('......... reporting peak bumps\n')
    esrlt <- as(eslst,'RleList')
    esrltsl <- slice(esrlt,sccut,rangesOnly=TRUE)
    esrltsl0 <- slice(esrlt,0,rangesOnly=TRUE)
    esrltsle <- reduce(shift(resize(esrltsl,width(esrltsl)+halfbdw*2),
                             -halfbdw))
    peaksir <- intersect(esrltsl0,esrltsle)
    peaksir <- peaksir[width(peaksir)>=halfbdw]
    cat('......... summarizing peak score and pvalue\n')
    peaksc <- unlist(viewMaxs(Views(esrlt,peaksir)))
    peaksir <- unlist(peaksir)
    regionids <- as.integer(names(peaksir))
    peaksir <- shift(peaksir,start(regionsrc)[regionids]+halfbdw*2-1)
    peaks <- GRanges(seqnames(regionsrc)[regionids],peaksir,es=peaksc)
    peaksrd <- reduce(peaks,min.gapwidth=halfbdw,with.revmap=TRUE)
    mcols(peaksrd)$es <- sapply(mcols(peaksrd)$revmap,function(i)
                                max(mcols(peaks)$es[i]))
    mcols(peaksrd)$revmap <- NULL
    pvs <- ecdf(perm)
    mcols(peaksrd)$pv <- 1 - pvs(mcols(peaksrd)$es)
    peaksrd
}
