#' @title GC Effects Aware Peak Calling
#'
#' @description
#' This function calls ChIP-seq peaks using potential GC effects information.
#' Enrichment scores are calculated on sliding windows of prefiltered
#' large regions, with GC effects considered. Permutation analysis is
#' used to determine significant binding peaks.
#'
#' @param cov A list object returned by function \code{read5endCoverage}.
#'
#' @param gcbias A list object returned by function \code{gcEffects}.
#'
#' @param bdwidth A non-negative integer specifying ChIP-seq binding width.
#' Usually generated by function \code{bindWidth}. A bad estimation of
#' bdwidth results no meaning of downstream analysis.Odd number is
#' preferred by the built in tricube smoothed weight.
#'
#' @param flank A non-negative integer specifying the flanking width of
#' ChIP-seq binding. This parameter provides the flexibility that reads
#' appear in flankings by decreased probabilities as increased distance
#' from binding region. This paramter helps to define the weight of GC
#' content calculation. Default is the half size of \code{bindWidth}. Note
#' that flank size won't largely affect results due to weighted strategy.
#'
#' @param prefilter A non-negative integer specifying the minimum of reads
#' to qualify a potential binding region. Regions with total of reads from
#' forward and reverse strands larger or equivalent to \code{prefilter} are
#' selected for downstream analysis. Default is 4.
#'
#' @param permute A non-negative integer specifying times of permutation to
#' be performed. Default is 10. When whole large genome is used, such as
#' human, 5 times of permutation could be enough.
#'
#' @param pv A numeric specifying p-value cutoff for significant
#' binding peaks. Default is 0.05.
#'
#' @param plot A logical vector which, when TRUE (default), returns density
#' plots of real and permutation enrichment scores.
#'
#' @param genome A \link[BSgenome]{BSgenome} object containing the sequences
#' of the reference genome that was used to align the reads, or the name of
#' this reference genome specified in a way that is accepted by the
#' \code{\link[BSgenome]{getBSgenome}} function defined in the \pkg{BSgenome}
#' software package. In that case the corresponding BSgenome data package
#' needs to be already installed (see \code{?\link[BSgenome]{getBSgenome}} in
#' the \pkg{BSgenome} package for the details).
#'
#' @return A GRanges of peaks with meta columns:
#' \item{es}{Estimated enrichment score.}
#' \item{pv}{p-value.}
#'
#' @import S4Vectors
#' @import IRanges
#' @import GenomicRanges
#' @import Biostrings
#' @importFrom BSgenome getBSgenome
#' @importFrom BSgenome getSeq
#' @importFrom splines ns
#' @importFrom stats predict
#' @importFrom stats density
#' @importFrom stats ecdf
#' @importFrom graphics plot
#' @importFrom graphics lines
#' @importFrom graphics abline
#' @importFrom graphics legend
#' @importFrom methods as
#'
#' @export
#' @examples
#' bam <- system.file("extdata", "chipseq.bam", package="gcapc")
#' cov <- read5endCoverage(bam)
#' bdw <- bindWidth(cov)
#' gcb <- gcEffects(cov, bdw, samp = 0.15)
#' gcapcPeaks(cov, gcb, bdw)

gcapcPeaks <- function(cov,gcbias,bdwidth,flank=floor(bdwidth/2),prefilter=4L,
                       permute=10L,pv=0.05,plot=FALSE,genome="hg19"){
    genome <- getBSgenome(genome)
    cat("Starting to call peaks.\n")
    ### prefiltering regions
    cat("...... prefiltering regions\n")
    seqs <- sapply(cov$fwd,length)
    seqs <- floor(seqs/bdwidth-2)*bdwidth
    starts <- lapply(seqs, function(i) seq(1+bdwidth*2, i, bdwidth))
    ends <- lapply(seqs, function(i) seq(bdwidth*3, i, bdwidth))
    chrs <- rep(names(seqs), times=sapply(starts, length))
    region <- GRanges(chrs, IRanges(start=unlist(starts),end=unlist(ends)))
    regionsp <- split(region,seqnames(region))
    halfbdw <- floor(bdwidth/2)
    rcfwd <- unlist(viewSums(Views(cov$fwd,
                                   ranges(shift(regionsp,-halfbdw)))))
    rcrev <- unlist(viewSums(Views(cov$rev,
                                   ranges(shift(regionsp,halfbdw)))))
    regions <- region[rcfwd+rcrev >= prefilter]
    rm(seqs,starts,ends,chrs,region,regionsp,rcfwd,rcrev)
    ## extend both ends
    regionsrc <- reduce(shift(resize(regions,halfbdw*8+1),-halfbdw*3))
    regionsgc <- shift(resize(regionsrc,width(regionsrc)+halfbdw*2),-halfbdw)
    rm(regions)
    ### gc content
    cat("...... caculating GC content\n")
    nr <- shift(resize(regionsgc,width(regionsgc)+flank*2),-flank)
    seqs <- getSeq(genome,nr)
    gcpos <- startIndex(vmatchPattern("S", seqs, fixed="subject"))
    w <- flank+halfbdw
    weight <- (1-abs(seq(-w,w)/w)^3)^3
    weight <- weight/sum(weight)
    gcposb <- vector("integer",sum(width(nr)))
    gcposbi <- rep(seq_along(nr),times=width(nr))
    gcposbsp <- split(gcposb,gcposbi)
    for(i in seq_along(nr)){
        gcposbsp[[i]][gcpos[[i]]] <- 1L
    }
    gcposbsprle <- as(gcposbsp,"RleList")
    gcnuml <- width(regionsgc)-halfbdw*2
    gcnum <- vector('numeric',sum(gcnuml))
    gcnumi <- rep(seq_along(nr),times=gcnuml)
    gc <- split(gcnum,gcnumi)
    for(i in seq_along(nr)){
        gc[[i]] <- round(runwtsum(gcposbsprle[[i]],k=length(weight),
                                  wt=weight),3)
        if(i%%500 == 0) cat('.')
    }
    cat('\n')
    rm(regionsgc,nr,seqs,gcpos,gcposb,gcposbi,
       gcposbsp,gcposbsprle,gcnuml,gcnum,gcnumi)
    ### gc weight
    cat("...... caculating GC effect weights\n")
    gcbase <- round(seq(0,1,0.001),3)
    mu0 <- predict(gcbias$glm0,data.frame(gc = gcbase),type="response")
    gcwbase <- round(Rle(median(gcbias$mu0[gcbias$z>0.5])/mu0),3)
    gcw <- RleList(lapply(gc,function(x) gcwbase[x*1000+1]))
    rm(gcbase,mu0,gc)
    ### reads count
    regionrcsp <- split(regionsrc,seqnames(regionsrc))
    rcfwd <- RleList(unlist(viewApply(Views(cov$fwd,ranges(regionrcsp)),
                                      runsum,k=bdwidth)))
    rcrev <- RleList(unlist(viewApply(Views(cov$rev,ranges(regionrcsp)),
                                      runsum,k=bdwidth)))
    ### enrichment score
    cat("...... estimating enrichment score\n")
    esl <- width(regionsrc)-halfbdw*4
    rc1 <- rcfwd[IRangesList(start=IntegerList(as.list(rep(1,length(esl)))),
                             end=IntegerList(as.list(esl)))]
    rc2 <- rcfwd[IRangesList(start=IntegerList(as.list(rep(1+halfbdw*2,
                             length(esl)))),
                             end=halfbdw*2+IntegerList(as.list(esl)))]
    rc3 <- rcrev[IRangesList(start=IntegerList(as.list(rep(1,length(esl)))),
                             end=IntegerList(as.list(esl)))]
    rc4 <- rcrev[IRangesList(start=IntegerList(as.list(rep(1+halfbdw*2,
                             length(esl)))),
                             end=halfbdw*2+IntegerList(as.list(esl)))]
    gcw1 <- gcw[IRangesList(start=IntegerList(as.list(rep(1+halfbdw*2,
                            length(esl)))),
                            end=halfbdw*2+IntegerList(as.list(esl)))]
    gcw2 <- gcw[IRangesList(start=IntegerList(as.list(rep(1+halfbdw*4,
                            length(esl)))),
                            end=halfbdw*4+IntegerList(as.list(esl)))]
    gcw3 <- gcw[IRangesList(start=IntegerList(as.list(rep(1,length(esl)))),
                            end=IntegerList(as.list(esl)))]
    esrlt <- round(2*sqrt(rc1*rc4)*gcw1-rc3*gcw3-rc2*gcw2,3)
    names(esrlt) <- seq_along(regionsrc)
    rm(rcfwd,rcrev,gcw,rc1,rc2,rc3,rc4)
    ### permutation analysis
    cat("...... permutation analysis\n")
    esprlt <- RleList()
    for(i in seq_len(permute)){
      covfwdp <- cov$fwd[ranges(regionrcsp)]
      covrevp <- cov$rev[ranges(regionrcsp)]
      for(i in seq_along(cov$fwd)){
        covfwdp[[i]] <- covfwdp[[i]][sample.int(length(covfwdp[[i]]))]
        covrevp[[i]] <- covrevp[[i]][sample.int(length(covrevp[[i]]))]
      }
      end <- cumsum(width(regionrcsp))
      start <- end-width(regionrcsp)+1
      regionrcspp <- IRangesList(start=start,end=end)
      rcfwdp <- RleList(unlist(viewApply(Views(covfwdp,regionrcspp),
                                         runsum,k=bdwidth)))
      rcrevp <- RleList(unlist(viewApply(Views(covrevp,regionrcspp),
                                         runsum,k=bdwidth)))
      rcp1 <- rcfwdp[IRangesList(start=
                                 IntegerList(as.list(rep(1,length(esl)))),
                                 end=IntegerList(as.list(esl)))]
      rcp2 <- rcfwdp[IRangesList(start=IntegerList(as.list(rep(1+halfbdw*2,
                                 length(esl)))),
                                 end=halfbdw*2+IntegerList(as.list(esl)))]
      rcp3 <- rcrevp[IRangesList(start=
                                 IntegerList(as.list(rep(1,length(esl)))),
                                 end=IntegerList(as.list(esl)))]
      rcp4 <- rcrevp[IRangesList(start=IntegerList(as.list(rep(1+halfbdw*2,
                                 length(esl)))),
                                 end=halfbdw*2+IntegerList(as.list(esl)))]
      esprlt <- c(esprlt,round(2*sqrt(rcp1*rcp4)*gcw1-rcp3*gcw3-rcp2*gcw2,3))
    }
    perm <- as.numeric(unlist(esprlt,use.names=FALSE))
    rm(covfwdp,covrevp,start,end,regionrcspp,rcp1,rcp2,rcp3,rcp4,
       rcfwdp,rcrevp,gcw1,gcw2,gcw3,esprlt,esl)
    ### report peaks
    cat('...... reporting peaks\n')
    sccut <- quantile(perm,1-pv)
    cat('......... enrichment scores cut at',sccut,'\n')
    if(plot){
        cat('......... ploting enrichment scores\n')
        es <- as.numeric(unlist(esrlt,use.names=FALSE))
        plot(density(perm,bw=1),col='blue',xlab='enrichment score',
             xlim=range(es),main=paste('es determined by pvalue',pv))
        lines(density(es,bw=1),col='red')
        abline(v=sccut,lty=2,col='purple')
        legend('topright',c('real','perm'),lty=1,
               col=c('red','blue'),bty='n')
        rm(es)
    }
    cat('......... reporting peak bumps\n')
    esrltsl <- slice(esrlt,sccut,rangesOnly=TRUE)
    esrltsl0 <- slice(esrlt,0,rangesOnly=TRUE)
    esrltsle <- reduce(shift(resize(esrltsl,width(esrltsl)+halfbdw*2),
                             -halfbdw))
    peaksir <- intersect(esrltsl0,esrltsle)
    peaksir <- peaksir[width(peaksir)>=halfbdw]
    rm(esrltsl,esrltsl0,esrltsle)
    cat('......... summarizing peak score and pvalue\n')
    peaksir <- unlist(peaksir)
    regionids <- as.integer(names(peaksir))
    peaksirlst <- IRangesList(start=IntegerList(as.list(start(peaksir))),
                              end=IntegerList(as.list(end(peaksir))))
    peaksc <- max(esrlt[regionids][peaksirlst])
    peaksir <- shift(peaksir,start(regionsrc)[regionids]+halfbdw*2-1)
    peaks <- GRanges(seqnames(regionsrc)[regionids],peaksir,es=peaksc)
    peaksrd <- reduce(peaks,min.gapwidth=halfbdw,with.revmap=TRUE)
    mcols(peaksrd)$es <- sapply(mcols(peaksrd)$revmap,function(i)
                                max(mcols(peaks)$es[i]))
    mcols(peaksrd)$revmap <- NULL
    pvs <- ecdf(perm)
    mcols(peaksrd)$pv <- 1 - pvs(mcols(peaksrd)$es)
    peaksrd
}
